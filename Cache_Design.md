# Cache Design

### 基本设计概览

#### 地址编码

0

高速缓存的设计为8KB的二路组相联，块大小设为32个字节，即8个字，每个字为一个bank，首先给出以下的32位物理地址编码规则。

###### Tag位（物理地址高位）：20位		Index位（组地址）：7位		Offset位（块内偏移）：5位

对于额外的标志位，有以下的设定。

###### Valid位（数据是否有效）：1位		Dirty位（脏标志）：一位

每一组有两路，共用一个LRU位。

###### LRU位（最近最少替换标志）：1位

脏标志是只有在弹出的时候才会使用，与Valid和Tag的使用方式区别较大，所以将其分开，最终，块的数据编码如下：

| Tag+Valid | Bank0 | Bank1 | Bank2 | Bank3 | Bank4 | Bank5 | Bank6 | Bank7 | Dirty |
| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   20+1    |  32   |  32   |  32   |  32   |  32   |  32   |  32   |  32   |   1   |


#### 主存写策略

当Cache写入主存中更新其数据的时候，采用的方式是写回方式，需要有脏数据的标记。当执行主存写指令的时候，若其数据存于Cache之中，则将Cache中的数据进行更改，并且同时将其所在块标记为“**脏**”。等到进行Cache数据替换脏块的时候，将脏块写入进内存中。

但是当Cache中没有指定的数据，那么首先从主存中读取指定的数据，再将其标记为脏。该策略被称为Write Allocate。

#### Cache数据替换策略

当Cache未命中的时候，或者说需要从主存中读数据写入Cache的时候，采用的策略是伪LRU（伪近期最少使用法），对于2路组相联，对每一组（set）都设置了一位的LRU标志，为0表示way0最近没有被使用，为1同理。LRU位决定了替换该组中的块时被替换的那一个。注意，被替换的数据若是dirty的话，就必须写入内存。

#### 整体的处理流程

为了增加器件复用的程度，设计中的读写整体处理流程都是追求一致的，具体如下，来自《超标量处理器设计》。

![image-20200629201539520](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200629201539520.png)

### 流水线设计

Cache的将从状态机版本转化为更为先进的三级流水线设计，三级流水线的设计相较于传统的两级设计来说，最大贡献就是避免了过高的组合延迟。在第一个状态，也就是look up中，FIFO的探查，以及TLB（MMU）的虚实地址的转换非常费时。

在三级中，多出来的第二级使得我们能够做合理的拆分，将原来的数据RAM和TAG RAM同时访问变为串行访问，先访问TAG，然后判断完TAG之后才访存对应的RAM，这样可以省去比较器的延时，也可以给TLB和FIFO以喘息时间。

在第三级中，我们将数据进行输出，如果命中失败，那么这个时候就需要在第三级中对总线发出读请求，同时发出cache以及cpu流水线的暂停请求，直到访存完毕。值得注意的是，第三级同样是写命令的数据准备好进入FIFO的时候，那么这个时候如果FIFO满了，也要暂停流水。



### 硬件架构设计



#### ICache接口设置

输入：

###### 全局信号：时钟clk，复位rst

###### CPU指令读写命令：读使能cpu_req_i，虚拟地址virtual_addr_i

输出：

###### CPU指令读命令结果：是否命中cache hit_o，当前数据是否有效 inst_valid_o，当前输出的数据inst_o

###### 总线slave信号：读数据有效mem_rvalid_i，读地址可以接收mem_arready_i，主存送入的块数据mem_rdata_i

###### 总线master信号：读使能mem_ren_o，读数据可以接收mem_rready_o，读地址有效mem_arvalid_o，读地址mem_araddr_o

注意：

###### hit_o：在req_i给出的下一个周期，其数据有效

#### DCache接口设置

输入：

###### 全局信号：时钟clk，复位rst

###### CPU指令读写命令：读使能cpu_rreq_i，写使能cpu_wreq_i，虚拟地址virtual_addr_i，写数据cpu_wdata_i

输出：

###### CPU指令读命令结果：是否命中cache hit_o，当前数据是否有效 inst_valid_o，当前输出的数据inst_o

###### 总线slave信号：读数据有效mem_rvalid_i，读地址可以接收mem_arready_i，主存送入的块数据mem_rdata_i

###### 总线master信号：读使能mem_ren_o，读数据可以接收mem_rready_o，读地址有效mem_arvalid_o，读地址mem_araddr_o

注意：

###### hit_o：在req_i给出的下一个周期，其数据有效

#### Cache_Ram的构造

为了存放相应的数据，对于每一路构造以下结构的Block Ram：

###### Tag+Valid：21位*128块\*2路（实际为了对齐8位采用24位）

###### Bank0~7：32位*128块\*2路

对于脏位和LRU则采用寄存器直接构建：

###### Dirty：1位*128块\*2路

###### LRU：1位*128块

关于地址，由Index指定块的深度（也就是组序号），由Offset指定块内偏移，下面具体明确与地址的对应关系：

###### Tag+Valid,Dirty的ram地址:Index

###### Tag+Valid,Dirty的ram选择使能:永远为真（两路全部取出）

###### Bank的ram地址：Index

###### Bank的具体使能：用B<sub>i</sub>W<sub>j</sub> 表示第i个bank，第j路，则有Offset[4:2]指明第i个bank，两路使能相同。

###### Dirty的ram地址：Index。

###### //这里应该要有一个3D的说明图，来表示RAM的构造关系

对于TagV ram，其中写入的数据永远是物理地址，只要将写入数据段与物理地址相接就可以了。

在非流水Cache中，对于ram来说，不会发生同时写和读的情况，但是在流水Cache中则会发生。ram必须直接组合逻辑连接于输入的addr，以保证一周期反应，那么在非流水Cache中就需要进行输入addr的选择，以保证能写能读。在流水Cache中，则需要使用多端口的ram同时进行读写，同时注意在同时进行读写的时候，如果两端口地址相同，输出的读数据将直接使用写入的数据（这部分需要自行实现），这部分是IP核自身的collision问题，需要进行规避。（顺带提醒：simple-dual ram完全等价于只开放A的write和B的read的true-dual ram）

#### 主存读命令：命中Cache

- 首先，将用TLB换算出来的物理地址拿出。
- 经过地址寻址，交付给cache_ram取出对应的数据。
- 进行对比确定是否命中，命中则返回。

#### 主存读命令：未命中Cache

- 读出ram的数据如果是脏块的话不要丢弃，**要送给WriteBuffer进行写入（这里还没有实现）**。
- 相应地址使能等交付给总线，之后开始等待。
- 数据返回后送出，同时将数据送给ram进行写回。

#### 主存写命令：命中Cache

- 首先，将用TLB换算出来的物理地址拿出。
- 经过地址寻址，交付给cache_ram取出对应的数据。
- 进行对比之后，将拿出的数据进行重写。
- 将数据进行写回。

#### 主存写命令：未命中Cache

- 首先，将用TLB换算出来的物理地址拿出。并且同时用虚拟地址地位赋予ram取数据，同时将物理地址给FIFO。
- 如果发现ram和FIFO都未命中，转

#### WriteBuffer: FIFO

该部件实质上是用来与总线进行数据交互的，作为写缓存，避免了流水和cache的堵塞，提高性能，但是要注意与cache的联合会出现以下的功能问题。

等待写回的数据在FIFO之中。若在写回之前，对于队列中的数据又出现了读/写操作，则需要将相应的数据抽离出来（这里头的才是最新数据，否则会出现数据错误），这不但可以加速读写的进程，还可以减少总线和FIFO的压力。

值得提出的是由于是以块为数据单位，那么地址位的比较就要做一定的额外处理。为了保证尽可能的低耦合性，对于任意的地址输入输出，都将Offset置0.

### 状态机设计：

##### 第一代

ICache的输入输出接口均为半成品，能够支持完成一定的功能，但是不能够进行完整的接口配置。其内部功能已经初步仿真正确，并且可综合和实现。

首先，采用状态机而非流水对对应的模块进行开发，读数据状态分配如下：

###### Look Up: 将地址传给TLB进行虚实地址转换，并将该地址给予相应的RAM。下一阶段进入Scan Cache

###### Scan Cache: 取出对应的cache数据，判断是否命中，将命中结果传出，若命中将数据也传出。命中后跳转到状态Look Up，没有则跳转到Read Fail。

###### Hit Fail: 等待至数据返回，（传递数据和地址给ram，下个周期才会写回），然后返回状态Look Up。

###### Write Back:拿到总线的数据之后直接将CPU需要的对应的数据送出，同时将对应的数据写回至cache中，下个周期返回状态Look Up。

DCache状态机：

###### Look Up: 将地址传给TLB进行虚实地址转换，并将该地址给予RAM。下一阶段进入Fetch Data

###### Fetch Data: 取出对应的cache数据，判断是否命中，若**读命中**,进行输出，之后跳转到Look Up，若**写命中**，设置好数据送入ram进行写入，之后进入Look Up。若**读不命中**，则与总线交互等待数据，之后进行关键字输出。若**写不命中**，同读不命中，但是写入数据必须考虑到cpu要求的写数据。若有脏块，进入Write Data。

###### Write FIFO: Fetch Data所获取的数据（写则需要加上cpu写数据的修改）写入FIFO。

对于不同阶段，都有固有的组合逻辑器件进行操作，状态机只相当于“流水线”中间分割的寄存器，但是为了功能的实现，目前的状态机不能够直接切分成流水。

将写入ram放在Fetch Data的最后一个周期，其中写数据的来源有如下情况：

###### 读未命中：总线数据

###### 写未命中：总线数据与脏块拼接

###### 写命中：分0路、1路、FIFO命中三种，分别拼接数据

对于脏标志的设置，在以下情况需要变动：

###### 读未命中：对应替换块脏位设0

###### 写未命中：对应替换块脏位设为1

###### 写命中但是不是FIFO命中：对应替换块脏位设为1（这个情况要注意）

对于主存写入，在以下情况会出现：

###### 读未命中：若弹出块（LRU决定）为脏块，则送入FIFO（使能也要有效）

###### 写未命中：若弹出块（LRU决定）为脏块，则送入FIFO（使能也要有效）

#### 剩余待实现的功能

- ~~Valid标志的判断~~
- ~~伪LRU~~~~（功能上实现之后进一步优化仿真代码、综合）~~
- ~~DCache~~
- 写回型store的实现
- ~~写入缓冲FIFO~~
- 总线块打包（完整的cache）
- 4路组相联16KBcache
- 流水切割（初具成果的cache）
- 硬件初始化（决赛的基本要求）
- 指令预取
- 双发射（最终成品的cache的基础版）
- Cache指令
- 这之后就是各种提升性能的关键所在了

### 待实现的拓展优化：

#### 双发射同时执行两条访存指令

#### TagV ram采用组合逻辑寄存器

#### VIPT

为了提升cache的查找性能，不被MMU的查找所拖累，首先先使用虚拟地址index进行查找，两者同时完成。之后来比较对应的tag（tag是物理地址，而非虚拟）是否命中。具体见知乎：https://zhuanlan.zhihu.com/p/107096130。

![img](https://pic4.zhimg.com/80/v2-12969d6792ebc4b5256e1822ffde6caf_720w.jpg)

