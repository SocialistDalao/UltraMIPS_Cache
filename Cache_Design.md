# Cache Design

### 基本设计概览



#### 主存写策略

当Cache写入主存中更新其数据的时候，采用的方式是写回方式，需要有脏数据的标记。当执行主存写指令的时候，若其数据存于Cache之中，则将Cache中的数据进行更改，并且同时将其所在块标记为“**脏**”。等到进行Cache数据替换脏块的时候，将脏块写入进内存中。

但是当Cache中没有指定的数据，那么首先从主存中读取指定的数据，再将其标记为脏。该策略被称为Write Allocate。

#### Cache数据替换策略

当Cache未命中的时候，或者说需要从主存中读数据写入Cache的时候，采用的策略是伪LRU（伪近期最少使用法），对于2路组相联，对每一组（set）都设置了一位的LRU标志，为0表示way0最近没有被使用，为1同理。LRU位决定了替换该组中的块时被替换的那一个。注意，被替换的数据若是dirty的话，就必须写入内存。

#### 整体的处理流程

为了增加器件复用的程度，设计中的读写整体处理流程都是追求一致的，具体如下，来自《超标量处理器设计》。

![image-20200629201539520](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200629201539520.png)

#### 地址编码

高速缓存的设计为8KB的二路组相联，块大小设为32个字节，即8个字，每个字为一个bank，首先给出以下的32位物理地址编码规则。

###### Tag位（物理地址高位）：20位		Index位（组地址）：7位		Offset位（块内偏移）：5位

对于额外的标志位，有以下的设定。

###### Valid位（数据是否有效）：1位		Dirty位（脏标志）：一位

每一组有两路，共用一个LRU位。

###### LRU位（最近最少替换标志）：1位

脏标志是只有在弹出的时候才会使用，与Valid和Tag的使用方式区别较大，所以将其分开，最终，块的数据编码如下：

| Tag+Valid | Bank0 | Bank1 | Bank2 | Bank3 | Bank4 | Bank5 | Bank6 | Bank7 | Dirty |
| :-------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   20+1    |  32   |  32   |  32   |  32   |  32   |  32   |  32   |  32   |   1   |



### 硬件架构设计



#### ICache接口设置

输入：

###### 全局信号：时钟clk，复位rst

###### CPU指令读写命令：读使能cpu_req_i，虚拟地址virtual_addr_i

输出：

###### CPU指令读命令结果：是否命中cache hit_o，当前数据是否有效 inst_valid_o，当前输出的数据inst_o

###### 总线slave信号：读数据有效mem_rvalid_i，读地址可以接收mem_arready_i，主存送入的块数据mem_rdata_i

###### 总线master信号：读使能mem_ren_o，读数据可以接收mem_rready_o，读地址有效mem_arvalid_o，读地址mem_araddr_o

注意：

###### hit_o：在req_i给出的下一个周期，其数据有效

#### DCache接口设置

输入：

###### 全局信号：时钟clk，复位rst

###### CPU指令读写命令：读使能cpu_rreq_i，写使能cpu_wreq_i，虚拟地址virtual_addr_i，写数据cpu_wdata_i

输出：

###### CPU指令读命令结果：是否命中cache hit_o，当前数据是否有效 inst_valid_o，当前输出的数据inst_o

###### 总线slave信号：读数据有效mem_rvalid_i，读地址可以接收mem_arready_i，主存送入的块数据mem_rdata_i

###### 总线master信号：读使能mem_ren_o，读数据可以接收mem_rready_o，读地址有效mem_arvalid_o，读地址mem_araddr_o

注意：

###### hit_o：在req_i给出的下一个周期，其数据有效

#### Cache_Ram的构造

为了存放相应的数据，对于每一路构造以下结构的Block Ram：

###### Tag+Valid：21位*128块\*2路（实际为了对齐8位采用24位）

###### Bank0~7：32位*128块\*2路

对于脏位和LRU则采用寄存器直接构建：

###### Dirty：1位*128块\*2路

###### LRU：1位*128块

关于地址，由Index指定块的深度（也就是组序号），由Offset指定块内偏移，下面具体明确与地址的对应关系：

###### Tag+Valid,Dirty的ram地址:Index

###### Tag+Valid,Dirty的ram选择使能:永远为真（两路全部取出）

###### Bank的ram地址：Index

###### Bank的具体使能：用B<sub>i</sub>W<sub>j</sub> 表示第i个bank，第j路，则有Offset[4:2]指明第i个bank，两路使能相同。

###### Dirty的ram地址：Index。

###### //这里应该要有一个3D的说明图，来表示RAM的构造关系

#### 主存读命令：命中Cache

- 首先，将用TLB换算出来的物理地址拿出。
- 经过地址寻址，交付给cache_ram取出对应的数据。
- 进行对比确定是否命中，命中则返回。

#### 主存读命令：未命中Cache

- 相应地址使能等交付给总线，之后开始等待。
- 数据返回后送出，同时将数据送给ram进行写回。

#### 主存写命令：命中Cache

- 首先，将用TLB换算出来的物理地址拿出。

- 经过地址寻址，交付给cache_ram取出对应的数据。
- 进行对比之后，将拿出的数据进行重写。
- 将数据进行写回。

### 设计迭代：

##### 第一代

ICache的输入输出接口均为半成品，能够支持完成一定的功能，但是不能够进行完整的接口配置。其内部功能已经初步仿真正确，并且可综合和实现。

首先，采用状态机而非流水对对应的模块进行开发，读数据状态分配如下：

###### Look Up: 将地址传给TLB进行虚实地址转换，并将该地址给予相应的RAM。下一阶段进入Scan Cache

###### Scan Cache: 取出对应的cache数据，判断是否命中，将命中结果传出，若命中将数据也传出。命中后跳转到状态Look Up，没有则跳转到Read Fail。

###### Hit Fail: 等待至数据返回，（传递数据和地址给ram，下个周期才会写回），然后返回状态Look Up。

###### Write Back:拿到总线的数据之后直接将CPU需要的对应的数据送出，同时将对应的数据写回至cache中，下个周期返回状态Look Up。

对于DCache的写数据：

###### Look Up: 将地址传给TLB进行虚实地址转换，并将该地址给予RAM。下一阶段进入Scan Cache

###### Scan Cache: 取出对应的cache数据，判断是否命中，若命中。命中后跳转到状态Write Back，没有则跳转到Hit Fail。

###### Hit Fail: 等待至数据返回，（传递数据和地址给ram，下个周期才会写回），然后返回状态Look Up。

###### Write Back:将相应的数据回写至RAM，并且设置脏位。

对于不同阶段，都有固有的组合逻辑器件进行操作，状态机只相当于“流水线”中间分割的寄存器。



#### 剩余待实现的功能

- ~~Valid标志的判断~~
- ~~伪LRU~~~~（功能上实现之后进一步优化仿真代码、综合）~~
- DCache
- 写回型store的实现
- 写入缓冲FIFO
- 总线块打包（完整的cache）
- 4路组相联16KBcache
- 流水切割（初具成果的cache）
- Cache指令
- 硬件初始化（决赛的基本要求）
- 指令预取
- 双发射（最终成品的cache的基础版）
- 这之后就是各种提升性能的关键所在了

### 待实现的拓展优化：

#### 双发射同时执行两条访存指令

#### VIPT

为了提升cache的查找性能，不被MMU的查找所拖累，首先先使用虚拟地址index进行查找，两者同时完成。之后来比较对应的tag（tag是物理地址，而非虚拟）是否命中。具体见知乎：https://zhuanlan.zhihu.com/p/107096130。

![img](https://pic4.zhimg.com/80/v2-12969d6792ebc4b5256e1822ffde6caf_720w.jpg)

